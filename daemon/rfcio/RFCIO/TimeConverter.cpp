/*
 * TimeConverter.cpp
 *
 */
#include <sstream>
#include <ctime>
#include <cstdio>
#include <cstring>
#include <ctype.h>
#include <inttypes.h>
#include <cassert>

#include "Commons/Convert.hpp"
#include "RFCIO/TimeConverter.hpp"

namespace RFCIO
{

TimeConverter::TimeConverter(void):
  the1900_(-2208988800)     // GNU epoch timestamp for 1990.01.01, midnight, UTC, generated by: date -d "1 Jan 1900 UTC" +%s
{
}

std::string TimeConverter::toNtpStamp(const Persistency::Timestamp &t) const
{
  const long     zero =0;                                       // 0==invalid/undefined according to RFC-1305
  const long     diff =std::max( t.get()-the1900_, zero );      // compute diff, or set to zero
  const long     stamp=(diff>0xFFFFFFFFu)?0:diff;               // out of range? only 32-bits are allowed.
  assert( stamp>=0 );
  assert( stamp<=0xFFFFFFFFu );
  const uint32_t major=Commons::Convert::to<uint32_t>(stamp);   // enusre proper range-check
  const uint32_t minor=0u;                                      // minor part is skipped
  //                 0xN*N.N*N\0
  char           buf[2+8+ 1 +2+8 + 1];
  sprintf(buf, "0x%08X.0x%08X", major, minor);
  assert( strlen(buf)+1==sizeof(buf) && "data didn't fit into buffer / format error" );
  return buf;
}

std::string TimeConverter::toString(const Persistency::Timestamp &t) const
{
  //               YYYY-MM-DDTHH:MM:SSZ
  char         buf[4+1 + 2+1 + 2 + 1 +2+1 + 2+1 +2 + 1 + 1];
  const time_t ts=t.get();
  struct tm    bt;
  if( gmtime_r(&ts, &bt)!=&bt )
    throw ExceptionInvalidTime(SYSTEM_SAVE_LOCATION, t, "gmtime_r() returned invalid pointer");
  // convert to output format
  sprintf(buf, "%04u-%02u-%02uT%02u:%02u:%02uZ",
               1900+bt.tm_year, 1+bt.tm_mon, bt.tm_mday,
               bt.tm_hour,      bt.tm_min,   bt.tm_sec);
  assert( strlen(buf)+1==sizeof(buf) && "data didn't fit into buffer / format error" );
  return buf;
}

TimeConverter::ExactTimestamp TimeConverter::fromNtpStamp(const std::string &str) const
{
  uint32_t major;
  uint32_t minor;
  if( str.length()!=2+8 + 1 + 2+8 )
    throw ExceptionInvalidTime(SYSTEM_SAVE_LOCATION, str, "invalid length");
  if( sscanf( str.c_str(), "0x%08X.0x%08X", &major, &minor )!=2 )
    throw ExceptionInvalidTime(SYSTEM_SAVE_LOCATION, str, "parsing error");
  // convert to final form
  const long   sec =major+the1900_;         // convert to GNU epoch
  const double frac=minor/(0xFFFFFFFF+1.0); // compute second fraction
  assert(frac>=0);
  assert(frac< 1);
  if(sec<0)
    throw ExceptionInvalidTime(SYSTEM_SAVE_LOCATION, str, "event is too old to represent");
  // return final result
  return ExactTimestamp( Persistency::Timestamp(sec), frac );
}


namespace
{
typedef std::pair<double, const char*> ParsedFraction;

ParsedFraction parseFraction(const std::string &wholeStr, const char *str)
{
  assert(str!=NULL);
  // no fraction part?
  if(*str!='.')
    return ParsedFraction(0, str);
  ++str;
  // sanity check
  if( !isdigit(*str) )
    throw TimeConverter::ExceptionInvalidTime(SYSTEM_SAVE_LOCATION, wholeStr, "invalid fraction part");
  // compute fraction part
  double numerator  =*str-'0';
  double denominator=10;
  ++str;
  while( isdigit(*str) )
  {
    numerator  *=10;
    numerator  +=*str-'0';
    denominator*=10;
    ++str;
  }
  const double fraction=numerator/denominator;
  // return pair: (fraction; place to start parsing from)
  return ParsedFraction(fraction, str);
}

int parseTimezoneOffset(const std::string &wholeStr, const char *str)
{
  assert(str!=NULL);
  // nothing more?!
  if(*str==0)
    throw TimeConverter::ExceptionInvalidTime(SYSTEM_SAVE_LOCATION, wholeStr, "to time zone information");
  // UTC - no timezone fix required
  if( strcmp(str, "Z")==0 )
    return 0;
  // it must mean that it's -HH:MM or +HH:MM format
  if( strlen(str)!=1+2+1+2 )    // format is SHH:MM
    throw TimeConverter::ExceptionInvalidTime(SYSTEM_SAVE_LOCATION, wholeStr, "timezone format is invalid");
  int sgn=0;
  switch(*str)
  {
    case '+': sgn=+1; break;
    case '-': sgn=-1; break;
    default:  throw TimeConverter::ExceptionInvalidTime(SYSTEM_SAVE_LOCATION, wholeStr, "invalid timezone sign");
  } // switch(sign)
  assert(sgn==-1 || sgn==+1);
  ++str;
  // parse hours and minutes
  int hh;
  int mm;
  if( sscanf(str, "%02d:%02d", &hh, &mm)!=2 )
    throw TimeConverter::ExceptionInvalidTime(SYSTEM_SAVE_LOCATION, wholeStr, "invalid timezone's hours/minutes format");

  // return timezone offset
  return -sgn*(hh*3600+mm);
} // parseTimezoneOffset()
} // unnamed namespace


TimeConverter::ExactTimestamp TimeConverter::fromString(const std::string &str) const
{
  struct tm bt;
  // parse input string
  sscanf(str.c_str(), "%04u-%02u-%02uT%02u:%02u:%02u",
                      &bt.tm_year, &bt.tm_mon, &bt.tm_mday,
                      &bt.tm_hour, &bt.tm_min, &bt.tm_sec);
  // fix some ranges and variables
  bt.tm_year -=1900;
  bt.tm_mon  -=1;
  bt.tm_isdst =-1;      // auto-detect day-light-saving
  // save copy of the original structure
  const struct tm btBck=bt;;
  // convert to time_t
  const time_t    tsLocal=mktime(&bt);
  // test if mktime() explicitly (?!) returned an error
  if( tsLocal==static_cast<time_t>(-1) )
    throw ExceptionInvalidTime(SYSTEM_SAVE_LOCATION, str, "mktime() returned error");
  // fix to skip local timezone
  const time_t  tsRead=tsLocal+bt.tm_gmtoff;
  // check timezone offset
  const char      *tzPart =str.c_str()+(4+1 + 2+1 + 2 + 1 +2+1 + 2+1 +2);
  ParsedFraction  fracTmp =parseFraction(str, tzPart);
  assert(fracTmp.first>=0);
  assert(fracTmp.first< 1);
  const int       tzOffset=parseTimezoneOffset(str, fracTmp.second);
  // compute actual time
  const time_t    utcTime =tsRead+tzOffset;
  // return final result
  return ExactTimestamp( Persistency::Timestamp(utcTime), fracTmp.first );
}

} // namespace RFCIO
