/*
 * TimeConverter.cpp
 *
 */
#include <sstream>
#include <ctime>
#include <cstdio>
#include <cstring>
#include <ctype.h>
#include <inttypes.h>
#include <cassert>

#include "Commons/Convert.hpp"
#include "RFCIO/TimeConverter.hpp"

namespace RFCIO
{

TimeConverter::TimeConverter(void):
  the1900_(-2208993840)     // GNU epoch timestamp for 1990.01.01, midnight, generated by: date -d "1 Jan 1900" +%s
{
}

std::string TimeConverter::toNtpStamp(const Persistency::Timestamp &t) const
{
  const long     zero =0;                                       // 0==invalid/undefined according to RFC-1305
  const long     diff =std::max( t.get()-the1900_, zero );      // compute diff, or set to zero
  const long     stamp=(diff>0xFFFFFFFFu)?0:diff;               // out of range? only 32-bits are allowed.
  assert( stamp>=0 );
  assert( stamp<=0xFFFFFFFFu );
  const uint32_t major=Commons::Convert::to<uint32_t>(stamp);   // enusre proper range-check
  const uint32_t minor=0u;
  //                 0xN*N.N*N\0
  char           buf[2+8+ 1 +2+8 + 1];
  sprintf(buf, "0x%08X.0x%08X", major, minor);
  assert( strlen(buf)+1==sizeof(buf) && "data didn't fit into buffer / format error" );
  return buf;
}

std::string TimeConverter::toString(const Persistency::Timestamp &t) const
{
  //               YYYY-MM-DDTHH:MM:SSZ
  char         buf[4+1 + 2+1 + 2 + 1 +2+1 + 2+1 +2 + 1 + 1];
  const time_t ts=t.get();
  struct tm    bt;
  if( gmtime_r(&ts, &bt)!=&bt )
    throw ExceptionInvalidTime(SYSTEM_SAVE_LOCATION, t, "gmtime_r() returned invalid pointer");
  // convert to output format
  sprintf(buf, "%04u-%02u-%02uT%02u:%02u:%02uZ",
               1900+bt.tm_year, 1+bt.tm_mon, bt.tm_mday,
               bt.tm_hour,      bt.tm_min,   bt.tm_sec);
  assert( strlen(buf)+1==sizeof(buf) && "data didn't fit into buffer / format error" );
  return buf;
}

Persistency::Timestamp TimeConverter::fromNtpStamp(const std::string &str) const
{
  uint32_t major;
  uint32_t minor;
  if( str.length()!=2+8 + 1 + 2+8 )
    throw ExceptionInvalidTime(SYSTEM_SAVE_LOCATION, str, "invalid length");
  if( sscanf( str.c_str(), "0x%08X.0x%08X", &major, &minor )!=2 )
    throw ExceptionInvalidTime(SYSTEM_SAVE_LOCATION, str, "parsing error");
  // minor is not needed
  const long sec=major+the1900_;    // convert to GNU epoch
  if(sec<0)
    throw ExceptionInvalidTime(SYSTEM_SAVE_LOCATION, str, "event is too old to represent");
  return Persistency::Timestamp(sec);
}


namespace
{
int parseTimezoneOffset(const std::string &wholeStr, const char *str)
{
  assert(str!=NULL);
  // are there second fractions present?
  if(*str=='.')
  {
    // skip all digits - they are not signifficant here
    do
    {
      ++str;
    }
    while( isdigit(*str) );
  } // if(second_fraction)

  // nothing more?!
  if(*str==0)
    throw TimeConverter::ExceptionInvalidTime(SYSTEM_SAVE_LOCATION, wholeStr, "to time zone information");
  // UTC - no timezone fix required
  if( strcmp(str, "Z")==0 )
    return 0;
  // it must mean that it's -HH:MM or +HH:MM format
  if( strlen(str)!=1+2+1+2 )    // format is SHH:MM
    throw TimeConverter::ExceptionInvalidTime(SYSTEM_SAVE_LOCATION, wholeStr, "timezone format is invalid");
  int sgn=0;
  switch(*str)
  {
    case '+': sgn=+1; break;
    case '-': sgn=-1; break;
    default:  throw TimeConverter::ExceptionInvalidTime(SYSTEM_SAVE_LOCATION, wholeStr, "invalid timezone sign");
  } // switch(sign)
  assert(sgn==-1 || sgn==+1);
  ++str;
  // parse hours and minutes
  int hh;
  int mm;
  if( sscanf(str, "%02d:%02d", &hh, &mm)!=2 )
    throw TimeConverter::ExceptionInvalidTime(SYSTEM_SAVE_LOCATION, wholeStr, "invalid timezone's hours/minutes format");

  // return timezone offset
  return sgn*(hh*3600+mm);
} // parseTimezoneOffset()
} // unnamed namespace


Persistency::Timestamp TimeConverter::fromString(const std::string &str) const
{
  struct tm bt;
  // parse input string
  sscanf(str.c_str(), "%04u-%02u-%02uT%02u:%02u:%02u",
                      &bt.tm_year, &bt.tm_mon, &bt.tm_mday,
                      &bt.tm_hour, &bt.tm_min, &bt.tm_sec);
  // fix some ranges and variables
  bt.tm_year -=1900;
  bt.tm_mon  -=1;
  bt.tm_isdst =-1;      // auto-detect day-light-saving
  // save copy of the original structure
  const struct tm btBck=bt;;
  // convert to time_t
  const time_t    tsLocal=mktime(&bt);
  // test if mktime() explicitly (?!) returned an error
  if( tsLocal==static_cast<time_t>(-1) )
    throw ExceptionInvalidTime(SYSTEM_SAVE_LOCATION, str, "mktime() returned error");
  // fix to skip local timezone
  const time_t  tsRead=tsLocal+bt.tm_gmtoff;
return Persistency::Timestamp(tsRead);                
  // check timezone offset
  const char   *tzPart  =str.c_str()+(4+1 + 2+1 + 2 + 1 +2+1 + 2+1 +2);
  const int     tzOffset=parseTimezoneOffset(str, tzPart);
  // compute actual time
  const time_t  utcTime =tsRead+tzOffset;
  return Persistency::Timestamp(utcTime);



  /*
  uint32_t major;
  uint32_t minor;
  if( str.length()!=2+8 + 1 + 2+8 )
    throw ExceptionInvalidTime(SYSTEM_SAVE_LOCATION, str);
  if( sscanf( str.c_str(), "0x%08X.0x%08X", &major, &minor )!=2 )
    throw ExceptionInvalidTime(SYSTEM_SAVE_LOCATION, str);
  // minor is not needed
  const long sec=major+the1900_;    // convert to GNU epoch
  if(sec<0)
    throw ExceptionInvalidTime(SYSTEM_SAVE_LOCATION, str);
  return Persistency::Timestamp(sec);
  */
}

} // namespace RFCIO
