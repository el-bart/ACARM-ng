IDMEFPtr
@function@(@param@ first, ...) {
	IDMEF_Type type = IDMEF_Type_@type@;
	IDMEFPtr idmefp, tidmefp;
	xmlChar *name = (xmlChar*)"@element@";
	xmlChar *content = (xmlChar *)first;
	char *f_name = "@function@";
	va_list ap;

	/* added possibility of creation of empty NODE */
        if (first == NULL && type != IDMEF_Type_NODE &&
        		     type != IDMEF_Type_CONTENT) {
#ifdef IDMEF_DEBUG
		fprintf(stderr, "%s: error: missing required argument\n",
			f_name);
#endif
		return (NULL);
	}

		
	if ((idmefp = libidmef_idmefp_create(type, name)) == NULL) {
#ifdef IDMEF_DEBUG
		fprintf(stderr, "%s: error: idmefp_create(%d, %s)\n",
			f_name, type, name);
#endif
		return (NULL);
	}

	va_start(ap, first);

	tidmefp = (IDMEFPtr)first;
        
	/*
	 * Once we start processing va_args we have to assume that the
	 * user was kind enough to provide enough arguments.  If not
	 * the results will be random strings.
	 */

	switch (type) {
		case IDMEF_Type_DOC:
		case IDMEF_Type_NODE:
			break;
		case IDMEF_Type_CONTENT:
                	/* check for at least one arg due to additional
                           possibility to create empty content idmefp */
                        if (!tidmefp)
                          goto out;
			/*
			 * We have to assume we're getting two arguments.
			 */
  			xmlNodeSetContent(idmefp->IDMEFXmlNodePtr, content);
			/*
			 * We loop through args for content to allow for
			 * content nodes with attributes.
			 */
			tidmefp = va_arg(ap, IDMEFPtr);
			break;
		case IDMEF_Type_ATTRIBUTE:
			/*
			 * We have to assume we're getting two arguments.
			 */
  			xmlSetProp(idmefp->IDMEFXmlNodePtr, name, content);
			/*
			 * We don't loop through args for attributes.
			 */
			goto out;
	}

	/*
	 * Process the arguments by type.
	 */
	for (; tidmefp != NULL; tidmefp = va_arg(ap, IDMEFPtr)) {
		libidmef_idmefp_lock_op(tidmefp, IDMEF_Lock_Op_READ_LOCK);
		switch (tidmefp->IDMEF_type) {
                case IDMEF_Type_DOC:
			break;
		case IDMEF_Type_NODE:
		case IDMEF_Type_CONTENT:
			/*
			 * Add this node as a child.
			 */
			libidmef_idmefp_lock_op(idmefp,
				IDMEF_Lock_Op_WRITE_LOCK);
			xmlAddChild(idmefp->IDMEFXmlNodePtr,
				tidmefp->IDMEFXmlNodePtr);
                        libidmef_list_insert (idmefp, tidmefp);
			libidmef_idmefp_lock_op(idmefp,
				IDMEF_Lock_Op_WRITE_UNLOCK);
			break;
		case IDMEF_Type_ATTRIBUTE:
			/*
			 * Add an attribute using the attribute
			 * contained in this node.
			 */
			libidmef_idmefp_lock_op(idmefp,
				IDMEF_Lock_Op_WRITE_LOCK);
			xmlSetProp(idmefp->IDMEFXmlNodePtr,
				tidmefp->IDMEFXmlNodePtr->properties->name,
				tidmefp->IDMEFXmlNodePtr->properties->children->content);
                        libidmef_list_insert (idmefp, tidmefp);
			libidmef_idmefp_lock_op(idmefp,
				IDMEF_Lock_Op_WRITE_UNLOCK);
//			xmlFreeNode(tidmefp->IDMEFXmlNodePtr);
			break;
		}
		libidmef_idmefp_lock_op(tidmefp, IDMEF_Lock_Op_READ_UNLOCK);
  	}

out:
	va_end(ap);
	return (idmefp);
}

